<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="css\indexCSS.css">
    <title>序章</title>
</head>
<body>
    <div id="chapters">
        <li><a href="index.html">序章</a></li>
        <li><a href="scr\L1.html">程序一</a></li>
        <li><a href="scr\L2.html">程序二</a></li>
        <li><a href="scr\L3.html">编程介绍</a></li>
    </div>
    
    <div id="dir">
        <dir>
            <li><a href="#class">类</a></li>
            <li><a href="#method">属性和方法</a></li>
            <li><a href="#init">实例化</a></li>
            <li><a href="#callback">回调</a></li>
            <li><a href="#agent">代理模式</a></li>
            <li><a href="#end">结尾</a></li>
        </dir>
    </div>
    <div id="CenterBox">
<h1 align="center">Java课程系列-序章</h1>
<p>&nbsp;&nbsp;正式开启Java的系统学习前，我们需要了解一些概念上的东西。比如我们翻译时经常遇到的所谓“类”，“方法”这些，该怎样去理解它们呢？</p>
<p><br></p>
<h2><a name="class">类</a></h2>
<p>&nbsp;&nbsp;首先是“类”。</p><p>&nbsp;&nbsp;我们常常说“人类”。那什么是人类呢？人有一个头，有四肢，有五脏六腑，所以就被称作“人类”吗？</p>
<img class="centerimg" id="img01" src="img/人类.png">
<p>&nbsp;&nbsp;显然，决定我们是“人类”而非“狗类”或“猫类”的，是我们作为“人类”所独有的行为与特征。</p><p>&nbsp;&nbsp;你与我，既不同名，也不长得一样，但我与你皆为人类。我们是“人类”这一个类别下的一个个独有的个体，也就是<b>对象</b>。
</p>
<p>&nbsp;&nbsp;万事万物皆对象，一个对象，必然有它所属的类（只讨论Java范围）。</p>
<br>
<h2><a name="method">属性和方法</a></h2>
<p>&nbsp;&nbsp;作为人类的我们，作为人类个体对象的我们，都有两只眼睛，一张嘴，还有两只耳朵，这是看得见摸得着的，
    看不见的，身高，体重，年龄等，这些就是人类的<b>属性</b>。</p><p>&nbsp;&nbsp;
    除了属性外，最起码都具备吃，喝，睡这些行为吧。吃饭，喝水，睡觉，思考，言语，这些是我们生来就有的，作为“人”这一类的能力，
    即我们的<b>方法</b>。</p>
<img id="img02" src="img\身高.png">
<img id="img03" src="img\睡觉.png">
<h3>示例一：人-类</h3>
<p>&nbsp;&nbsp;类就好比一个模板，一份蓝图，它刻画了由它所产生的对象所具备的属性和方法。</p><p>&nbsp;&nbsp;现在，请尝试阅读一份简陋的人类模板：</p>
<img id="img04" src="img\Person.png">
<br>
<h2><a name="init">类的实例化-new方式</a></h2>
<p>&nbsp;&nbsp;有了模板后，我们就可以造一个实在的人出来。
<br>（注：实在指数据在内存中真实存在。）
</p><p>&nbsp;&nbsp;通常，我们使用new的方式来对类进行实例化，实例化后得到一个对象。代码格式为：
</p>
<p><b>类名 自定义对象名 = new 类名();</b></p>
<p>&nbsp;&nbsp;如下我们便得到了一个名为skipper的人类对象。</p>
<img class="centerimg" src="img\skipper.png">
<p>&nbsp;&nbsp;（注：<b>Person()</b>看似像个方法，实则是类的构造器，构造器是类能够生成对象的原因。构造器如无特殊要求默认省略，但不代表不存在。）</p>
<p>&nbsp;&nbsp;现在，我们有了这个叫<b>skipper</b>的对象，依照上面的类模板，skipper拥有姓名（<b>name</b>）、年龄（<b>age</b>）、身高（<b>height</b>）、
    体重（<b>weight</b>）、
    体温（<b>temperature</b>）、国籍（<b>country</b>）、所操语言（<b>language</b>）、性别（<b>isMale</b>）等属性，并具备吃饭（<b>eat()</b>）、睡觉（<b>sleep()</b>）、
    说话（<b>speak()</b>）等行为能力，即方法。但是请注意，<b>skipper</b>的属性还都没有赋值，我们可以按需给<b>skipper</b>赋值让他变得更加具象化。
    比如，我们可以赐予<b>skipper</b>一个姓名，属性<b>name</b>的前面有个词-<b>String</b>，它表示了<b>name</b>属性的类型，
    即字符串类型。<br>通过<b>object.attribute = value;</b>的方式，我们可以对对象的属性，按照模板规定的数值类型进行赋值：</p>
    <img class="centerimg" src="img\赋值name.png">
<p>&nbsp;&nbsp;如图所示，<b>skipper</b>已被我赐予了<b>Skipper</b>的名字。其他属性就不一一赋值了，因为本篇除了<b>name</b>属性其他属性并不需要用到。</p>
<p>&nbsp;&nbsp;接着我们试试来调用一下skipper看看会发生什么吧。
</p><p>&nbsp;&nbsp;我们来调用一下skipper的几个方法：
    </p>
<img class="centerimg" src="img\callmethod.png">
<p>&nbsp;&nbsp;通过<b>object.method(parameter);</b>的方式，我们可以调用一个对象所具有的方法。</p><p>&nbsp;
    通过模板可以看出，这三个方法都是在控制台打印结果的，其中<b>speak()</b>方法中需要传入一个String类型，名为<b>words</b>的参数。<br>
    &nbsp;&nbsp;我们来运行一下程序看看：
    </p>
<img class="centerimg" src="img\runningresult.png">
<p>&nbsp;&nbsp;Skipper成功做到了吃饭、睡觉、说一句简单的话。
    此刻你的感受是什么样的呢，是觉得神奇，还是觉得：这不就是显示出几句文字嘛，我直接打字出来不比这快多了？</p><p>
        &nbsp;&nbsp;诚然，这只是在控制台上打印几句无聊的文字，但或许，我们可以放开一下想象力，倘使Skipper被存在一个遥控器里，
    我们按下遥控器就可以调用它的一个方法，比如，叫做<b>hotWater()</b>，这个方法体里不再是简单控制台打印文字，
    而是远程连接家里的网络，进而连接到家里能够联网的淋浴设备。</p><p>
        &nbsp;&nbsp;下班后，你拿出遥控器，调用Skipper的hotWater方法，家里的热水器便开始启动加热。待你回到家后，热水刚刚烧好......
    </p><br>
<h2><a name="callback">回调</a></h2>
<p>&nbsp;&nbsp;假使现在有一个这样的场景：</p><p>&nbsp;&nbsp;冬天，天气很冷，我（<b>temperature=30</b>）与张三（<b>temperature=31</b>）一同待在一个房间内，
    此时我发现屋子的窗户没关，难怪这么冷！窗户一定要关上。我和张三都具有关窗户的能力（方法），因为我比张三更冷，很不想动弹，
    于是我便叫（调用）张三去关窗户（假设关窗的方法为<b>closeWinodw()</b>），并要他告诉我关窗户的结果。
    张三起身去关窗户，这时可能会有这样两种结果：</p><p>&nbsp;&nbsp;结果一：张三关上了窗户，我的<b>temperature</b>的值上升到了<b>32</b>，
    张三还到我面前跟我说：“窗户关上了。”（成功回调）。</p><p>&nbsp;&nbsp;结果二：张三没能关上窗户，
    因为窗户是坏的，我的<b>temperature</b>依然是<b>30</b>，张三到我面前说了原因。（失败回调）。</p>
<img class="centerimg" src="img\window.png">
<p>&nbsp;&nbsp;回调并不是必须的，只是我让张三去关窗户的时候，也对他发出了告知我结果的命令。
    在这样的场景中，我与张三都是对象，作为一个对象的我，call了张三做什么事情，这种说法其实并不是很规范，因为通常能call的，
    是开发者。但作为独立个体的我，实际上能不能让张三去实现他所具有的方法呢？这是可以的，
    只不过我让张三去做某事的这件事本身，就是我自己所有的一个方法，有一个更高级别的人，
    或许是开发者，他对我发出了命令（调用），让我去叫张三去关窗户。这种模式就叫做代理模式。
    正如歌手都会有自己的经纪人，歌手负责唱歌，歌手也可以唱完歌收钱，但为了各司其职，收钱通常是让经纪人负责。
    </p><br>
<h2><a name="agent">代理模式</a></h2>
<p>&nbsp;&nbsp;我们来展开说一下代理这回事。<br>&nbsp;
    现在有一个类，叫做歌手类（<b>Singer</b>），歌手类继承了人类，人类所有的属性和方法，歌手类的对象也都继承到了，
    所以歌手必然是一个人。&nbsp;&nbsp;我们使用new的方式，新建一个歌手类的对象，并给对象起名为“大明星”。有另一个类，
    叫做经纪人类（<b>Agent</b>），同样，该类也继承了人类，因此经纪人必定也是一个人。我们使用new的方式，
    新建了一个经纪人，暂且就叫做“李四”吧。</p><p>&nbsp;&nbsp;为什么要强调他们必定是一个人呢？因为人类里定义了一个方法：收钱。
    大明星和李四都能收钱，但大明星作为歌手，他的主要职能是唱歌，收钱这种小事，还是让李四去做吧。
    我们来看看大明星和李四各自都是什么样的结构。 
    </p>
<p>&nbsp;&nbsp;首先是经纪人的模板：</p>
<img class="centerimg" src="img\Agent.png">
<p>&nbsp;&nbsp;没错，乍一看基本什么都没有。但，真的是什么都没有吗？</p>
<p>&nbsp;&nbsp;关键字<b>extends</b><br>&nbsp;&nbsp;extends字面意思是“扩展”，中文习惯说“继承”，在这里，<b>Agent</b>这个类继承了<b>Person</b>这个类
    （<b>Person</b>类模板见上方人类模板）。
    通过继承的方式，<b>Person</b>类里定义的属性和方法全部给到了<b>Agent</b>类，由此，就没必要再把人类里定义的属性和方法再放到经纪人类里写一遍了。</p>
<p>&nbsp;&nbsp;接着是歌手的模板：</p>
<img class="centerimg" src="img\Singer.png">
<p>&nbsp;&nbsp;同样可以看到，<b>Singer</b>类也继承了<b>Person</b>类，于是不必要的定义省去了。但是又可以看到，<b>Singer</b>类多了一个属性，
    这个属性叫<b>agent</b>。
    还有既然继承了，为什么<b>Singer</b>类的<b>sing()</b>方法还要再写一遍呢，不过看方法体内的代码与<b>Person</b>类中定义的<b>sing()</b>并不同。
    （方法的重写。这里体现了<b>extends</b>的“扩展”层面的意思。）
</p><p>&nbsp;&nbsp;再看<b>agent</b>，它的类型是<b>Agent</b>，这个Agent是我们定义的那个经纪人类吗？难道类也可以作为属性？</p>
<p>&nbsp;&nbsp;答：是的，这里的<b>Agent</b>就是指<b>Agent</b>类，一个类可以作为另一个类的属性出现。</p><p>
    &nbsp;&nbsp;我们把<b>Agent</b>绑定给<b>Singer</b>，就好比每个大明星都有自己的经纪人一样，经纪人就是明星的一个属性。
    </p>
<p>&nbsp;&nbsp;我们来看看代码是怎么处理的吧：</p>
<img class="centerimg" src="img\示例1.PNG">
<p>&nbsp;&nbsp;控制台结果如下：</p>
<img class="centerimg" src="img\console.PNG">
<p>&nbsp;&nbsp;由于我们在<b>Singer</b>类中重写了继承于<b>Person</b>类的<b>sing()</b>方法，即在方法体中又调用了一次<b>Agent</b>类中的收钱方法，
    当我们调用唱歌方法时，结果并不只是大明星完成唱歌，
    还顺带让另一个对象经纪人去收了钱。
    这，就叫代理模式。</p><p>&nbsp;&nbsp;
    就算<b>Person</b>类中如果没有<b>getMoney()</b>方法，即我们剥夺了大明星收钱的能力，
    但只要<b>Agent</b>类中定义了<b>getMoney()</b>方法，
    那即便大明星连买菜都不会，也不会唱完歌赚不到钱了。
</p>
<br>
<h2><a name="end">结尾</a></h2>
<p>&nbsp;&nbsp;Java开发里的模式还有很多，但仅从这个代理模式就可以看出，Java程序的开发逻辑，是非常贴近于现实中的逻辑的。原因就在于Java是一门面向对象的编程语言。在Java中，所有功能的完成基本都是由一个个对象来实现的。我们要前往月球，那就造一艘宇宙飞船的对象，飞船需要燃料，
我们就造燃料的对象......</p>

<p>&nbsp;&nbsp;本篇课程只是简单地带大家体会一下Java的开发大致是怎么一回事。实际真正开发中，需要调用的操作有很多，逻辑也比较严密和复杂，但那并不是作为翻译的我们需要关心的事。

</p>
</div>  
</body>
</html>
